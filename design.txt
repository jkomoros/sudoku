dokugen must be able to solve Sudoku itself to be able to generate them.

A simple BFS of statespace on constraints should be fastest. But to get difficulty, we'll need to solve as a human does.

We'll have a fastSolve, which uses a constrained BFS, and a humanSolve, which proceeds knowing a grid can be solved and returns a difficulty.

Grids are passed back and forth over channels. They should be easily serializable and small whenever possible, but still be fast for common operations. You may read and write to them only if you have a ref, and you can only get a ref via a channel.


Grid {
	data string
	cells Cell[DIM * DIM]
}

TODO:
* Make it so Number doesn't return implicitNumbers; solve will set each one explicitly.
* A FinitePriorityQueue. Takes low (we'll use 1) and max int. Things must implement a Rank() int method. Inside, it's a [DIM]RankedObject. Each Get will verify its rank again before returning. Objects should call Insert() again whenever their rank may have changed. 
* Grid should suppot copy operations and have copy-on-write semantics with shared cells.
* Have some way for cell.invalid(), when it's been called, to alert back up that an inconsistency has been found.