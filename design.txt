dokugen must be able to solve Sudoku itself to be able to generate them.

A simple BFS of statespace on constraints should be fastest. But to get difficulty, we'll need to solve as a human does.

We'll have a fastSolve, which uses a constrained BFS, and a humanSolve, which proceeds knowing a grid can be solved and returns a difficulty.

Grids are passed back and forth over channels. They should be easily serializable and small whenever possible, but still be fast for common operations. You may read and write to them only if you have a ref, and you can only get a ref via a channel.


Grid {
	data string
	cells Cell[DIM * DIM]
}

TODO:

* GetGrid() and ReturnGrid() allow us to reuse grids internally.
* Another way of handling doneChan is to have one that counts how many to accept, and how many to expect. That way each thread can die instead of having to wait for its children to finish.
* Replace Fill() with a better implementation (isn't there a known polynomial time solution?). In the worst case, the work for the next bullet will unlock it.
* In cases where we're only interested in A solution or 2 solutions, we can bail out early. In that case, we'll want to use channels and we'll want to do some kind of best first search  where there are workers that pull grids off the list to operate on next (using FiniteQueue, (no modificaitons necessary to be threadsafe as long as we create a new grid at each branch). In that world, as soon as the main thread branches it will want to end.
* Test how much more slowly the channel implementation of Solutions() goes.

* Grid should suppot copy operations and have copy-on-write semantics with shared cells.
* A way to generate filled squares (to start removing things from)
* Actualy generate sudokus
* Rate sudokus based on experienced difficulty.