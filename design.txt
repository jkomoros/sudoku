dokugen must be able to solve Sudoku itself to be able to generate them.

A simple BFS of statespace on constraints should be fastest. But to get difficulty, we'll need to solve as a human does.

We'll have a fastSolve, which uses a constrained BFS, and a humanSolve, which proceeds knowing a grid can be solved and returns a difficulty.

Grids are passed back and forth over channels. They should be easily serializable and small whenever possible, but still be fast for common operations. You may read and write to them only if you have a ref, and you can only get a ref via a channel.


Grid {
	data string
	cells Cell[DIM * DIM]
}

TODO:
* Replace Fill() with a better implementation (isn't there a known polynomial time solution?). In the worst case, the work for the next bullet will unlock it.
	* The current implementation is basically a BFS, which is exactly terrible for puzzles with many branch points and many solutions. An ideal solution would fill up NUM_SOLVE_PROCS with work BFS style and then do a DFS if there are no other waiting cores of work. If some kind of inGrids could block, there could be a default case for it to "screw it" and go it alone. But that would require each thread to be able to tell immediately if others want work, which precludes the single-counter-dispatcher model. Hmmmm...
	* Maybe the main solve func takes an argument of if it needs to signal up on the channel or not when it's done, or if returning up is fine. at the branch point, it tries to push work onto counter (which blocks on other threads picking work off its gridsToProcess queue.) If it can't push it in immediately, (because counter is blocked waiting for another worker to grab something off gridsToProcess), then it calls direclty into the child and takes responsibility for its results (wait, there could be multiple results down there, and we might only want one of them). Hmmmm...
	* Probably the way to do it is a synchronized FiniteQueue
		* We'll need a SynchornizedFiniteQueue to wrap FiniteQueue
			* Wait, what if just the counter maintains the queue? Then it doesn't need to be synced.
		* FiniteQueue will need to accept negative numbers (or be able to flip to negative queue)

* Grid should suppot copy operations and have copy-on-write semantics with shared cells.
* A way to generate filled squares (to start removing things from)
* Actualy generate sudokus
* Rate sudokus based on experienced difficulty. (See http://www.longwood.edu/assets/mathematics/Team2975_ProblemB.pdf)